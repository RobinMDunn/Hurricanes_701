# Basic visualization functions -----------------------


#' Format curves from a list to a single data.frame
#'
#' @param test_list list of curves
#' @param position position of lat and long columns in the test_list dataframes
#'
#' @return single data frame with all curves (curve column with idx of curve)
#' @export
#'
data_plot_paths_basic <- function(test_list, position = 1:2) {
  
  data_out <- data.frame(lat = -360,
                         long = -360,
                         curve = 0)
  
  for (i in 1:length(test_list)) {
    data_out <- rbind(data_out,
                      data.frame(
                        lat = test_list[[i]][, position[2]],
                        long = test_list[[i]][, position[1]],
                        curve = i
                      ))
  }
  data_out <- data_out[-1, ]
  
  return(data_out)
  
}

#' Visualize TC Paths (with \code{ggplot})
#'
#' @param data_out data frame with correct path information same as outputted 
#'       from \code{\link{data_plot_paths_basic}} functions. If supplied with a 
#'       list of data frames of paths of TCs (like inputted into 
#'       \code{\link{data_plot_paths_basic}}), then the function will apply
#'       \code{\link{data_plot_paths_basic}} first. \emph{Note: will assume
#'       "\code{position = 1:2}" unless altered in \code{...}, see 
#'       documentation for \code{\link{data_plot_paths_basic}} for details.}
#' @param zoom map zoom for ggmap
#' @param base_graph ggplot object for base graph 
#'       (created from data_out otherwise)
#' @param alpha opacity of curves 
#' @param ... can pass \code{position} values if desirable
#'
#' @return ggplot visualisation of the curve
#' @export
ggvis_paths <- function(data_out, zoom = 4,
                        base_graph = NULL, alpha = .01, ...){
  
  if (class(data_out) == "list"){
    data_out <- data_plot_paths_basic(test_list = data_out, ...)
  }

  if (is.null(base_graph)) {
    latrange <- range(data_out$lat)
    longrange <- range(data_out$long)
    
    ocean <- c(left = longrange[1], bottom = latrange[1],
               right = longrange[2], top = latrange[2])
    map   <- ggmap::get_stamenmap(ocean, zoom = zoom, maptype = "toner-lite")
    
    base_graph <- ggmap::ggmap(map)
  } 
  
  # final map ---------------
  ggout <- base_graph + ggplot2::geom_path(data = data_out, 
                                  ggplot2::aes_string(x = 'long', y = 'lat', 
                                                      group = 'curve'),
                                  alpha = alpha) 
  
  return(ggout)
}


# KDE contour visualization functions -----------------------

#' Create list of data frames to visualize KDE contour
#'
#' @param contour_list unnamed list of contour elements, of 
#' \itemize{
#' \item level The contour level.
#' \item x The x-coordinates of the contour.
#' \item y The y-coordinates of the contour.
#' }
#' 
#' This list has the same format as the \code{contour} element generated by
#' \code{\link{kde_from_tclist}}
#'
#' @return a list of data frames (\code{x}, \code{y}, and \code{level} columns)
#' @export
contour_list_to_df <- function(contour_list){
  contour_list_of_df <- list()
  for (i in 1:length(contour_list)) {
    contour_list_of_df[[i]] <- data.frame(x = contour_list[[i]]$x,
                                     y = contour_list[[i]]$y,
                                     level = contour_list[[i]]$level
    )
  }
  return(contour_list_of_df)
}



#' Create ggplot of kde set of contour
#' 
#' @param level_contour_list list of data frame of level contours that can be 
#'        be produced from putting the a list object into the 
#'        function \code{\link{contour_list_to_df}}, which expects to take in
#'        the \code{contour} piece of objects outputed by the 
#'        \code{\link{kde_from_tclist}}. 
#'        
#'        \emph{Note: If one inserts a list
#'        of data frames or matrices (assumed to a list of TCs), that this 
#'        function will attempt to create the kde PB using 
#'        \code{\link{kde_from_tclist}} and process to data and make the visual.
#'        If one inserts a list with sub-elements named \code{contour}, 
#'        \code{area}, \code{kde_object} (assumed to be output from 
#'        \code{\link{kde_from_tclist}}), then the function will apply 
#'        \code{\link{contour_list_to_df}} to the \code{contour} component. 
#'        If you are making this function create the full KDE PB, please make
#'        sure to pass a \code{alpha} in to make the object (see 
#'        \code{\link{kde_from_tclist}} for details). }
#'        
#' @param base_graph ggplot object for base graph 
#'       (created from data_out otherwise)
#' @param zoom map zoom for \code{\link[ggmap]{ggmap}}
#' @param color color of band
#' @param ... interior \code{\link[ggplot2]{geom_path}} or 
#'        \code{\link{kde_from_tclist}} parameters.
#'
#' @return ggplot object of contour and data points.
#' @export
#' @examples 
#' kde_list_object <- kde_from_tclist(sample_sim, alpha = .05)
#' level_contour_list <- contour_list_to_df(kde_list_object$contour)
#' 
#' # standard usage of the function
#' ggvis_kde_contour(level_contour_list, color = "red")
#' 
#' # using the KDE PB object:
#' ggvis_kde_contour(kde_list_object, color = "blue")
#' 
#' # using the simulated curves:
#' ggvis_kde_contour(sample_sim, color = "purple", alpha = .05)
ggvis_kde_contour <- function(level_contour_list, base_graph = NULL,
                              zoom = 4, color = "pink", ...){
  
   
  if (all(c("contour", "area", "kde_object") %in% names(level_contour_list))) {
    #^object is from kde_from_tclist function
    level_contour_list <- contour_list_to_df(level_contour_list$contour)
  } else if (!all(c("x", "y", "level") %in% names(level_contour_list[[1]]))){
    #^if object is a list of TCs
    kde_list_object <- kde_from_tclist(level_contour_list, ...)
    level_contour_list <- contour_list_to_df(kde_list_object$contour)
  } 

  
  if (is.null(base_graph)) {
    latrange <- range(sapply(level_contour_list, function(df){
                              range(df$y)}))
    longrange <- range(sapply(level_contour_list, function(df){
      range(df$x)}))
    ocean <- c(left = longrange[1], bottom = latrange[1],
               right = longrange[2], top = latrange[2])
    map   <- ggmap::get_stamenmap(ocean, zoom = zoom, maptype = "toner-lite")
    
    base_graph <- ggmap::ggmap(map)
  } 
  
  ggout <- base_graph  
  for (i in 1:length(level_contour_list)) {
    ggout <- ggout + 
      ggplot2::geom_path(data = level_contour_list[[i]],
                         ggplot2::aes_string(x = "x", y = "y"),
                         color = color)
  }
  return(ggout)
}


# Delta Ball Visualization function ------------------------

#' Visualize delta ball exterior centers (with ggplot)
#'
#' \strong{This function needs to be corrected. Lat and Long seem to be switched 
#' around. Goes all the way back to \code{delta_ball_wrapper}}
#'
#' @param output_lines data frame of exterior lines (not ordered) of the form
#'        returned from \code{\link{delta_ball_wrapper}} or the \code{structure}
#'        element in the returned list from \code{\link{delta_structure}}.
#' @param base_graph ggplot object for base graph 
#'       (created from output_lines otherwise)
#' @param zoom map zoom for \code{\link[ggmap]{ggmap}}
#' @param color color of band
#' @param ... interior \code{\link[ggplot2]{geom_path}} parameters or 
#'        also to pass \emph{only} the \code{alpha} input for the 
#'        \code{\link{delta_structure}} function.
#'
#' @return ggplot object of contours
#' @export
#' @examples 
#' # takes as while
#' sample_sim_small <- list()
#' for (i in 1:10){
#'   sample_sim_small[[i]] <- sample_sim[[i]]
#'   }
#' 
#' delta_PB <- delta_structure(sample_sim_small, alpha = .05, area_ci_n = 1,
#'                             verbose = TRUE) 
#' 
#' # for now since delta_ball_wrapper seems to be wrong
#' ggvis_delta_ball_contour(delta_PB$structure, color = "red", 
#'                          base_graph = ggplot2::ggplot())
#' 
#' ggvis_delta_ball_contour(sample_sim_small, alpha = .05, 
#'                          base_graph = ggplot2::ggplot(), color = "red")
ggvis_delta_ball_contour <- function(output_lines, base_graph = NULL, zoom = 4,
                                     color = "pink", ...){
  dots <- list(...)

  if (class(output_lines)  == "list") {
    #^ assume this means that the object is a list of simulated curves
    
    delta_info <- delta_structure(output_lines, alpha = dots$alpha,
                                        area_ci_n = 1)
    output_lines <- delta_info$structure
    dots$alpha <- NULL
  }
  
  ... <- unlist(dots)

  if (is.null(base_graph)) {
    latrange <- range(output_lines$lat)
    longrange <- range(output_lines$long)
    
    ocean <- c(left = longrange[1], bottom = latrange[1],
               right = longrange[2], top = latrange[2])
    map   <- ggmap::get_stamenmap(ocean, zoom = zoom, maptype = "toner-lite")
    
    base_graph <- ggmap::ggmap(map)
  } 
  
  ggout <- base_graph + 
    ggplot2::geom_line(data = output_lines, 
                       ggplot2::aes_string(y = 'long', x = 'lat', group = 'idx'),
                       color = color, ...)
  
  return(ggout)
}

# Convex Hull visualization function ---------------------------


#' Visualize delta ball exterior centers (with \code{ggplot})
#'
#' @param output_lines data frame of exterior lines, should be ordered 
#'        correctly, structure of that return of 
#'        \code{\link{convex_hull_structure}}'s \code{poly_df} attribute. One 
#'        can also either pass the list output from 
#'        \code{\link{convex_hull_structure}} or a list of simulated curves.
#'        If it recieves a list that is not the output of 
#'        \code{\link{convex_hull_structure}} it will assume it is a list of 
#'        simulated curves and 
#'        the function will use \code{\link{convex_hull_structure}} to create 
#'        the correct convex hull PB to visualize. \emph{Note: if passing the 
#'        full list of TCs, you will need to pass in an \code{alpha} parameter 
#'        like that required in \code{\link{convex_hull_structure}}.}
#' @param base_graph ggplot object for base graph 
#'       (created from output_lines otherwise)
#' @param zoom map zoom for \code{\link[ggmap]{ggmap}}
#' @param color color of band
#' @param ... interior \code{\link[ggplot2]{geom_path}} or the 
#'        \code{convex_hull_structure} parameters \emph{(Note: at this time,
#'        only the required \code{alpha} parameter will be accepted for the
#'        \code{convex_hull_structure} function)}
#'
#' @return \code{ggplot} object of contour
#' @export
#' 
#' @details Very similar function to \code{\link{ggvis_delta_ball_contour}}
#' 
#' @examples 
#' # takes as while
#' sample_sim_small <- list()
#' for (i in 1:10){
#'   sample_sim_small[[i]] <- sample_sim[[i]]
#'   }
#' 
#' convex_PB <- convex_hull_structure(sample_sim_small, alpha = .05)
#' output_lines <- convex_PB$poly_df
#' 
#' # standard approach:
#' ggvis_convex_hull(output_lines, color = "red")
#' 
#' ggvis_convex_hull(convex_PB, color = "blue")
#' 
#' ggvis_convex_hull(sample_sim_small, color = "purple", alpha = .05)
ggvis_convex_hull <- function(output_lines, base_graph = NULL, zoom = 4,
                                     color = "pink", ...){
  
  dots <- list(...)
  if (class(output_lines) == "list") {
    if ("poly_df" %in% names(output_lines)) {
      output_lines <- output_lines$poly_df
    } else{
      output_lines <- convex_hull_structure(output_lines, 
                                            alpha = dots$alpha)$poly_df
      dots$alpha <- NULL
    }
  }
  
  ... <- unlist(dots)
  
  # names(output_lines)[names(output_lines) == "long"] <- "lon"
  
  if (is.null(base_graph)) {
    latrange <- range(output_lines$lat)
    longrange <- range(output_lines$long)
    
    ocean <- c(left = longrange[1], bottom = latrange[1],
               right = longrange[2], top = latrange[2])
    map   <- ggmap::get_stamenmap(ocean, zoom = zoom, maptype = "toner-lite")
    
    base_graph <- ggmap::ggmap(map)
  } 
  
  ggout <- base_graph + 
    ggplot2::geom_path(data = output_lines, 
                       ggplot2::aes_string(y = 'lat', x = 'long'),
                       color = color, ...)
  
  return(ggout)
}


# Bubble visualization functions -------------------------


#' Plot lines for Spherical PB
#' 
#' \strong{Warning: this function does lat and long in reverse. This 
#' goes back beyond the wrapper \code{\link{bubble_ci_from_tclist}}}
#'
#' @param bubble_plot_data list of center points, positive and negative 
#'        tangential points (each a n x 2 data frame), similar to the 
#'        \code{bubble_CI_object} element in the output of the return from
#'        \code{\link{bubble_ci_from_tclist}}. One can also input a list of 
#'        TCs and the function will create the needed structure using 
#'        \code{\link{bubble_ci_from_tclist}}. \emph{If using a list of TCs, 
#'        must include a \code{alpha} in \code{...} parameters.}
#' @param base_graph plot to add to
#' @param centers boolean to decide whether to also plot centers (as points)
#' @param connect boolean to connect the left and right final tangential points
#' @param color color of band
#' @param linewidth width of line
#' @param zoom map zoom for \code{\link[ggmap]{ggmap}}
#' @param ... Interior \code{\link[ggplot2]{geom_path}} or the 
#'        \code{bubble_ci_from_tclist} parameters \emph{(Note: at this time,
#'        only the required \code{alpha} parameter will be accepted for the
#'        \code{bubble_ci_from_tclist} function)}
#'
#' @return \code{ggplot} object with curves on it
#' @export
#'
#' @examples
#' # takes as while
#' sample_sim_small <- list()
#' for (i in 1:10){
#'   sample_sim_small[[i]] <- sample_sim[[i]]
#'   }
#' 
#' dflist_13pointsreduction <- thirteen_points_listable(sample_sim_small, 
#'                                                     position = 1:2)
#' dist_matrix_13pointsreduction <- distMatrixPath_innersq(
#'   dflist_13pointsreduction)

#' depth_vector <- depth_function(dist_matrix_13pointsreduction)
#' depth_vector_idx <- which(depth_vector == max(depth_vector))[1]
#' 
#' spherical_PB <- bubble_ci_from_tclist(sample_sim_small, 
#'                                           center_idx = depth_vector_idx,
#'                                           alpha = .05)
#' 
#' bubble_plot_data <- spherical_PB$bubble_CI_object
#' 
#' # standard approach:
#' ggvis_bubble_data(bubble_plot_data, color = "red", 
#'                   base_graph = ggplot2::ggplot())
#' 
#' ggvis_bubble_data(sample_sim_small, color = "purple", alpha = .05,
#'                   base_graph = ggplot2::ggplot())
ggvis_bubble_data <- function(bubble_plot_data, base_graph = NULL,
                              centers = FALSE, connect = TRUE,
                              color = "pink", linewidth = 1, zoom = 4,
                              ...){
  
  dots <- list(...)
  
  if (!all(c("positive", "negative", "centers", "radius") %in% names(bubble_plot_data))) {
    dflist_13pointsreduction <- thirteen_points_listable(bubble_plot_data, 
                                                         position = 1:2,
                                                         verbose = FALSE)
    dist_matrix_13pointsreduction <- distMatrixPath_innersq(
                                                  dflist_13pointsreduction,
                                                  verbose = FALSE)
    
    depth_vector <- depth_function(dist_matrix_13pointsreduction)
    depth_vector_idx <- which(depth_vector == max(depth_vector))[1]
    
    spherical_PB <- bubble_ci_from_tclist(bubble_plot_data, 
                                              center_idx = depth_vector_idx,
                                              alpha = dots$alpha)
    bubble_plot_data <- spherical_PB$bubble_CI_object
    dots$alpha <- NULL
  }
  
  ... <- unlist(dots)
  
  data_plot_lower <- data.frame(bubble_plot_data$positive)
  names(data_plot_lower)[1:2] <- c("lat", "long")
  data_plot_upper <- data.frame(bubble_plot_data$negative)
  names(data_plot_upper)[1:2] <- c("lat", "long")
  
  if (is.null(base_graph)) {
    
    data_all <- rbind(data_plot_lower, data_plot_upper)
    latrange <- range(data_all$lat)
    longrange <- range(data_all$long)
    
    ocean <- c(left = longrange[1], bottom = latrange[1],
               right = longrange[2], top = latrange[2])
    map   <- ggmap::get_stamenmap(ocean, zoom = zoom, maptype = "toner-lite")
    
    base_graph <- ggmap::ggmap(map)
    
  } 
  
  ggout <- base_graph + 
    ggplot2::geom_path(data = data_plot_lower, 
                       ggplot2::aes_string(x = 'lat', y = 'long'), 
              color = color, size = linewidth, ...) +
    ggplot2::geom_path(data = data_plot_upper, 
                       ggplot2::aes_string(x = 'lat', y = 'long'), 
              color = color, size = linewidth, ...) 
  
  if (centers) {
    ggout <- ggvis_bubble_data_centers_inner(bubble_plot_data, base_graph = ggout, 
                              color = color, zoom = 4, ...)
  }
  
  if (connect) {
    n_final <- nrow(data_plot_lower)
    ggout <- ggout + ggplot2::geom_segment(data = 
                            data.frame(x = data_plot_lower[n_final,"lat"],
                                       y = data_plot_lower[n_final,"long"],
                                       xend = data_plot_upper[n_final,"lat"],
                                       yend = data_plot_upper[n_final,"long"]),
                            ggplot2::aes_string(x = "x",
                                                y = "y",
                                                xend = "xend",
                                                yend = "yend"),
                            color = color, size = linewidth)
  }
  
  return(ggout)
}


#' Inner Plot centers for bubble data
#'
#' @param bubble_plot_data list of center points, lower and upper tangential 
#' points (each a n x 2 data frame)
#' @param base_graph plot to add points to
#' @param color color of points
#' @param zoom map zoom for ggmap
#' @param ... Interior ggpath parameters
#'
#' @return ggplot object with points on it
ggvis_bubble_data_centers_inner <- function(bubble_plot_data, base_graph = NULL, 
                                         color = "pink", zoom = 4, ...){
  
  center <- data.frame(bubble_plot_data$center)
  names(center)[1:2] <- c("lat", "long")
  
  if (is.null(base_graph)) {
    latrange <- range(center$lat)
    longrange <- range(center$long)
    
    ocean <- c(left = longrange[1], bottom = latrange[1],
               right = longrange[2], top = latrange[2])
    map   <- ggmap::get_stamenmap(ocean, zoom = zoom, maptype = "toner-lite")
    
    base_graph <- ggmap::ggmap(map)
  } 
  
  ggout <- base_graph + 
    ggplot2::geom_point(data = center, ggplot2::aes_string(x = 'lat', y = 'long'),
               color = color, ...)
  
  return(ggout)
}
